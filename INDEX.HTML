<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>–ú–∏–Ω–∏-–ò–≥—Ä—ã –¥–ª—è Telegram</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #f6d365 0%, #fda085 100%);
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            color: #333;
        }
        h1 {
            text-align: center;
            color: #fff;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
            margin: 20px 0;
        }
        .game-container {
            width: 90%;
            max-width: 400px;
            margin: 10px;
            padding: 20px;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            transition: transform 0.3s;
        }
        .game-container:hover {
            transform: scale(1.02);
        }
        button {
            padding: 12px 24px;
            margin: 10px;
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            transition: background 0.3s;
        }
        button:hover {
            background: linear-gradient(135deg, #45a049 0%, #4CAF50 100%);
        }
        #menu {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }
        .hidden {
            display: none;
        }

        /* Tic-Tac-Toe Styles */
        #tic-tac-toe-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-gap: 10px;
            margin: 20px auto;
            max-width: 300px;
        }
        .cell {
            aspect-ratio: 1;
            background-color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 60px;
            cursor: pointer;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            transition: background 0.3s;
        }
        .cell:hover {
            background-color: #f0f0f0;
        }

        /* Memory Game Styles */
        #memory-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-gap: 10px;
            margin: 20px auto;
            max-width: 300px;
        }
        .card {
            aspect-ratio: 1;
            background-color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            cursor: pointer;
            border-radius: 10px;
            transition: transform 0.6s;
            transform-style: preserve-3d;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .card.flipped {
            transform: rotateY(180deg);
            background-color: #fff;
        }
        .card .front {
            backface-visibility: hidden;
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            transform: rotateY(180deg);
        }
        .card .back {
            backface-visibility: hidden;
            background-color: #ddd;
            width: 100%;
            height: 100%;
            border-radius: 10px;
        }
        .card.matched {
            background-color: #4CAF50;
            color: white;
        }

        /* Snake Game Styles */
        #snake-canvas {
            border: 2px solid #333;
            border-radius: 10px;
            display: block;
            margin: 20px auto;
            background-color: #fff;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        #snake-controls {
            display: flex;
            justify-content: center;
            margin-top: 10px;
        }
        #snake-controls button {
            font-size: 24px;
            padding: 10px;
            margin: 5px;
            width: 60px;
            height: 60px;
        }

        /* 2048 Game Styles */
        #game-2048-board {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-gap: 10px;
            margin: 20px auto;
            max-width: 300px;
            background-color: #bbada0;
            padding: 10px;
            border-radius: 10px;
        }
        .tile {
            aspect-ratio: 1;
            background-color: #cdc1b4;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
            font-weight: bold;
            color: #776e65;
            border-radius: 5px;
            transition: background 0.3s;
        }

        /* Rock-Paper-Scissors Styles */
        #rps-options {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }
        #rps-options button {
            font-size: 40px;
            margin: 0 10px;
        }
        #rps-result {
            text-align: center;
            font-size: 20px;
            margin: 10px 0;
        }

        /* Battleship Styles (Simplified for single device multi) */
        #battleship-grids {
            display: flex;
            justify-content: space-around;
        }
        .battleship-grid {
            display: grid;
            grid-template-columns: repeat(5, 40px);
            grid-gap: 2px;
        }
        .bs-cell {
            width: 40px;
            height: 40px;
            background-color: #ddd;
            cursor: pointer;
            border-radius: 5px;
        }
        .bs-hit {
            background-color: red;
        }
        .bs-miss {
            background-color: blue;
        }

        /* Puzzle Slider Styles */
        #puzzle-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-gap: 5px;
            margin: 20px auto;
            max-width: 300px;
            position: relative;
        }
        .puzzle-tile {
            aspect-ratio: 1;
            background-color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            cursor: pointer;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            transition: transform 0.3s;
        }
        .empty {
            background-color: transparent;
            box-shadow: none;
        }
    </style>
</head>
<body>
    <h1>–ú–∏–Ω–∏-–ò–≥—Ä—ã</h1>
    <div id="menu">
        <button onclick="startGame('tic-tac-toe')">–ö—Ä–µ—Å—Ç–∏–∫–∏-–ù–æ–ª–∏–∫–∏ (2 –∏–≥—Ä–æ–∫–∞)</button>
        <button onclick="startGame('memory')">–ò–≥—Ä–∞ –Ω–∞ –ü–∞–º—è—Ç—å (1 –∏–≥—Ä–æ–∫)</button>
        <button onclick="startGame('snake')">–ó–º–µ–π–∫–∞ (1 –∏–≥—Ä–æ–∫)</button>
        <button onclick="startGame('2048')">2048 (1 –∏–≥—Ä–æ–∫)</button>
        <button onclick="startGame('rps')">–ö–∞–º–µ–Ω—å-–ù–æ–∂–Ω–∏—Ü—ã-–ë—É–º–∞–≥–∞ (2 –∏–≥—Ä–æ–∫–∞)</button>
        <button onclick="startGame('battleship')">–ú–æ—Ä—Å–∫–æ–π –ë–æ–π (2 –∏–≥—Ä–æ–∫–∞)</button>
        <button onclick="startGame('puzzle')">–°–ª–∞–π–¥–µ—Ä-–ü–∞–∑–ª (1 –∏–≥—Ä–æ–∫)</button>
    </div>

    <!-- Tic-Tac-Toe -->
    <div id="tic-tac-toe" class="game-container hidden">
        <h2>–ö—Ä–µ—Å—Ç–∏–∫–∏-–ù–æ–ª–∏–∫–∏</h2>
        <div id="tic-tac-toe-board"></div>
        <p id="tic-tac-toe-status">–•–æ–¥: X</p>
        <button onclick="resetTicTacToe()">–°–±—Ä–æ—Å–∏—Ç—å</button>
        <button onclick="backToMenu()">–ù–∞–∑–∞–¥</button>
    </div>

    <!-- Memory Game -->
    <div id="memory" class="game-container hidden">
        <h2>–ò–≥—Ä–∞ –Ω–∞ –ü–∞–º—è—Ç—å</h2>
        <div id="memory-grid"></div>
        <p id="memory-status">–ù–∞–π–¥–∏—Ç–µ –ø–∞—Ä—ã!</p>
        <button onclick="resetMemory()">–°–±—Ä–æ—Å–∏—Ç—å</button>
        <button onclick="backToMenu()">–ù–∞–∑–∞–¥</button>
    </div>

    <!-- Snake Game -->
    <div id="snake" class="game-container hidden">
        <h2>–ó–º–µ–π–∫–∞</h2>
        <canvas id="snake-canvas" width="280" height="280"></canvas>
        <p id="snake-score">–°—á–µ—Ç: 0</p>
        <div id="snake-controls">
            <button onclick="changeDirection('UP')">‚Üë</button>
            <div>
                <button onclick="changeDirection('LEFT')">‚Üê</button>
                <button onclick="changeDirection('RIGHT')">‚Üí</button>
            </div>
            <button onclick="changeDirection('DOWN')">‚Üì</button>
        </div>
        <button onclick="resetSnake()">–°–±—Ä–æ—Å–∏—Ç—å</button>
        <button onclick="backToMenu()">–ù–∞–∑–∞–¥</button>
    </div>

    <!-- 2048 Game -->
    <div id="2048" class="game-container hidden">
        <h2>2048</h2>
        <div id="game-2048-board"></div>
        <p id="game-2048-score">–°—á–µ—Ç: 0</p>
        <button onclick="reset2048()">–°–±—Ä–æ—Å–∏—Ç—å</button>
        <button onclick="backToMenu()">–ù–∞–∑–∞–¥</button>
    </div>

    <!-- Rock-Paper-Scissors -->
    <div id="rps" class="game-container hidden">
        <h2>–ö–∞–º–µ–Ω—å-–ù–æ–∂–Ω–∏—Ü—ã-–ë—É–º–∞–≥–∞</h2>
        <p>–ò–≥—Ä–æ–∫ 1: –í—ã–±–µ—Ä–∏—Ç–µ</p>
        <div id="rps-options">
            <button onclick="playRPS('rock')">‚úä</button>
            <button onclick="playRPS('scissors')">‚úåÔ∏è</button>
            <button onclick="playRPS('paper')">üñêÔ∏è</button>
        </div>
        <p id="rps-result"></p>
        <button onclick="resetRPS()">–°–±—Ä–æ—Å–∏—Ç—å</button>
        <button onclick="backToMenu()">–ù–∞–∑–∞–¥</button>
    </div>

    <!-- Battleship -->
    <div id="battleship" class="game-container hidden">
        <h2>–ú–æ—Ä—Å–∫–æ–π –ë–æ–π (–£–ø—Ä–æ—â–µ–Ω–Ω—ã–π)</h2>
        <p id="battleship-status">–†–∞—Å—Å—Ç–∞–Ω–æ–≤–∫–∞ –∫–æ—Ä–∞–±–ª–µ–π –¥–ª—è –ò–≥—Ä–æ–∫–∞ 1</p>
        <div id="battleship-grids">
            <div id="player1-grid" class="battleship-grid"></div>
            <div id="player2-grid" class="battleship-grid hidden"></div>
        </div>
        <button onclick="startBattleshipPlay()">–ù–∞—á–∞—Ç—å –∏–≥—Ä—É</button>
        <button onclick="resetBattleship()">–°–±—Ä–æ—Å–∏—Ç—å</button>
        <button onclick="backToMenu()">–ù–∞–∑–∞–¥</button>
    </div>

    <!-- Puzzle Slider -->
    <div id="puzzle" class="game-container hidden">
        <h2>–°–ª–∞–π–¥–µ—Ä-–ü–∞–∑–ª</h2>
        <div id="puzzle-grid"></div>
        <p id="puzzle-status">–°–æ–±–µ—Ä–∏—Ç–µ —á–∏—Å–ª–∞ –ø–æ –ø–æ—Ä—è–¥–∫—É!</p>
        <button onclick="resetPuzzle()">–°–±—Ä–æ—Å–∏—Ç—å</button>
        <button onclick="backToMenu()">–ù–∞–∑–∞–¥</button>
    </div>

    <script>
        // –û–±—â–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏
        function startGame(gameId) {
            document.getElementById('menu').classList.add('hidden');
            document.getElementById(gameId).classList.remove('hidden');
            if (gameId === 'tic-tac-toe') initTicTacToe();
            if (gameId === 'memory') initMemory();
            if (gameId === 'snake') initSnake();
            if (gameId === '2048') init2048();
            if (gameId === 'rps') initRPS();
            if (gameId === 'battleship') initBattleship();
            if (gameId === 'puzzle') initPuzzle();
        }

        function backToMenu() {
            document.querySelectorAll('.game-container').forEach(el => el.classList.add('hidden'));
            document.getElementById('menu').classList.remove('hidden');
            if (snakeInterval) clearInterval(snakeInterval);
        }

        // –ö—Ä–µ—Å—Ç–∏–∫–∏-–ù–æ–ª–∏–∫–∏ (2 –∏–≥—Ä–æ–∫–∞, –ø–æ –æ—á–µ—Ä–µ–¥–∏ –Ω–∞ –æ–¥–Ω–æ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ)
        let tttBoard = Array(9).fill(null);
        let tttCurrentPlayer = 'X';
        let tttGameOver = false;

        function initTicTacToe() {
            const board = document.getElementById('tic-tac-toe-board');
            board.innerHTML = '';
            for (let i = 0; i < 9; i++) {
                const cell = document.createElement('div');
                cell.classList.add('cell');
                cell.dataset.index = i;
                cell.addEventListener('touchend', handleTicTacToeClick); // –¢–∞—á –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö
                board.appendChild(cell);
            }
            updateTicTacToeStatus('–•–æ–¥: X');
            tttBoard = Array(9).fill(null);
            tttCurrentPlayer = 'X';
            tttGameOver = false;
        }

        function handleTicTacToeClick(e) {
            e.preventDefault();
            if (tttGameOver) return;
            const index = e.target.dataset.index;
            if (tttBoard[index]) return;
            tttBoard[index] = tttCurrentPlayer;
            e.target.textContent = tttCurrentPlayer;
            if (checkTicTacToeWin()) {
                updateTicTacToeStatus(`–ü–æ–±–µ–¥–∏–ª ${tttCurrentPlayer}!`);
                tttGameOver = true;
            } else if (tttBoard.every(cell => cell)) {
                updateTicTacToeStatus('–ù–∏—á—å—è!');
                tttGameOver = true;
            } else {
                tttCurrentPlayer = tttCurrentPlayer === 'X' ? 'O' : 'X';
                updateTicTacToeStatus(`–•–æ–¥: ${tttCurrentPlayer}`);
            }
        }

        function checkTicTacToeWin() {
            const wins = [
                [0,1,2], [3,4,5], [6,7,8],
                [0,3,6], [1,4,7], [2,5,8],
                [0,4,8], [2,4,6]
            ];
            return wins.some(combo => combo.every(i => tttBoard[i] === tttCurrentPlayer));
        }

        function updateTicTacToeStatus(msg) {
            document.getElementById('tic-tac-toe-status').textContent = msg;
        }

        function resetTicTacToe() {
            initTicTacToe();
        }

        // –ò–≥—Ä–∞ –Ω–∞ –ü–∞–º—è—Ç—å (1 –∏–≥—Ä–æ–∫)
        let memoryCards = [];
        let flippedCards = [];
        let matchedPairs = 0;

        function initMemory() {
            const grid = document.getElementById('memory-grid');
            grid.innerHTML = '';
            const symbols = ['üçé', 'üçå', 'üçí', 'üçá', 'üçâ', 'üçì', 'üçë', 'üçç'];
            memoryCards = [...symbols, ...symbols].sort(() => Math.random() - 0.5);
            for (let i = 0; i < memoryCards.length; i++) {
                const card = document.createElement('div');
                card.classList.add('card');
                card.dataset.index = i;
                const back = document.createElement('div');
                back.classList.add('back');
                const front = document.createElement('div');
                front.classList.add('front');
                front.textContent = memoryCards[i];
                card.appendChild(back);
                card.appendChild(front);
                card.addEventListener('touchend', handleMemoryClick);
                grid.appendChild(card);
            }
            flippedCards = [];
            matchedPairs = 0;
            updateMemoryStatus('–ù–∞–π–¥–∏—Ç–µ –ø–∞—Ä—ã!');
        }

        function handleMemoryClick(e) {
            e.preventDefault();
            if (flippedCards.length >= 2) return;
            const index = e.target.closest('.card').dataset.index;
            const card = document.querySelector(`.card[data-index="${index}"]`);
            if (flippedCards.includes(index) || card.classList.contains('matched')) return;
            card.classList.add('flipped');
            flippedCards.push(index);
            if (flippedCards.length === 2) {
                setTimeout(checkMemoryMatch, 1000);
            }
        }

        function checkMemoryMatch() {
            const [idx1, idx2] = flippedCards;
            const card1 = document.querySelector(`.card[data-index="${idx1}"]`);
            const card2 = document.querySelector(`.card[data-index="${idx2}"]`);
            if (memoryCards[idx1] === memoryCards[idx2]) {
                card1.classList.add('matched');
                card2.classList.add('matched');
                matchedPairs++;
                if (matchedPairs === memoryCards.length / 2) {
                    updateMemoryStatus('–í—ã –≤—ã–∏–≥—Ä–∞–ª–∏!');
                }
            } else {
                card1.classList.remove('flipped');
                card2.classList.remove('flipped');
            }
            flippedCards = [];
        }

        function updateMemoryStatus(msg) {
            document.getElementById('memory-status').textContent = msg;
        }

        function resetMemory() {
            initMemory();
        }

        // –ó–º–µ–π–∫–∞ (1 –∏–≥—Ä–æ–∫, –∫–Ω–æ–ø–∫–∏ –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö)
        let snakeCanvas, snakeCtx, snake, food, direction = 'RIGHT', score, snakeInterval;

        function initSnake() {
            snakeCanvas = document.getElementById('snake-canvas');
            snakeCtx = snakeCanvas.getContext('2d');
            snake = [{x: 140, y: 140}, {x: 130, y: 140}, {x: 120, y: 140}];
            food = generateFood();
            score = 0;
            updateSnakeScore();
            snakeInterval = setInterval(updateSnake, 150);
        }

        function changeDirection(newDir) {
            if ((newDir === 'LEFT' && direction !== 'RIGHT') ||
                (newDir === 'RIGHT' && direction !== 'LEFT') ||
                (newDir === 'UP' && direction !== 'DOWN') ||
                (newDir === 'DOWN' && direction !== 'UP')) {
                direction = newDir;
            }
        }

        function updateSnake() {
            const head = {...snake[0]};
            if (direction === 'RIGHT') head.x += 10;
            if (direction === 'LEFT') head.x -= 10;
            if (direction === 'UP') head.y -= 10;
            if (direction === 'DOWN') head.y += 10;

            if (head.x >= 280 || head.x < 0 || head.y >= 280 || head.y < 0 || snake.some((s, i) => i > 0 && s.x === head.x && s.y === head.y)) {
                clearInterval(snakeInterval);
                alert('–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞! –°—á–µ—Ç: ' + score);
                return;
            }

            snake.unshift(head);

            if (head.x === food.x && head.y === food.y) {
                score++;
                updateSnakeScore();
                food = generateFood();
            } else {
                snake.pop();
            }

            drawSnake();
        }

        function drawSnake() {
            snakeCtx.clearRect(0, 0, 280, 280);
            snakeCtx.fillStyle = '#4CAF50';
            snake.forEach(s => snakeCtx.fillRect(s.x, s.y, 10, 10));
            snakeCtx.fillStyle = 'red';
            snakeCtx.fillRect(food.x, food.y, 10, 10);
        }

        function generateFood() {
            let x = Math.floor(Math.random() * 28) * 10;
            let y = Math.floor(Math.random() * 28) * 10;
            return {x, y};
        }

        function updateSnakeScore() {
            document.getElementById('snake-score').textContent = `–°—á–µ—Ç: ${score}`;
        }

        function resetSnake() {
            clearInterval(snakeInterval);
            initSnake();
        }

        // 2048 (1 –∏–≥—Ä–æ–∫, —Ç–∞—á-—Å–≤–∞–π–ø—ã)
        let board2048 = Array.from({length: 4}, () => Array(4).fill(0));
        let score2048 = 0;
        let touchStartX, touchStartY;

        function init2048() {
            board2048 = Array.from({length: 4}, () => Array(4).fill(0));
            score2048 = 0;
            addRandomTile();
            addRandomTile();
            draw2048Board();
            update2048Score();
            const board = document.getElementById('game-2048-board');
            board.addEventListener('touchstart', handleTouchStart);
            board.addEventListener('touchend', handleTouchEnd);
        }

        function addRandomTile() {
            const empty = [];
            board2048.forEach((row, i) => row.forEach((val, j) => { if (val === 0) empty.push({i, j}); }));
            if (empty.length === 0) return;
            const {i, j} = empty[Math.floor(Math.random() * empty.length)];
            board2048[i][j] = Math.random() < 0.9 ? 2 : 4;
        }

        function draw2048Board() {
            const grid = document.getElementById('game-2048-board');
            grid.innerHTML = '';
            board2048.flat().forEach(val => {
                const tile = document.createElement('div');
                tile.classList.add('tile');
                tile.textContent = val || '';
                tile.style.backgroundColor = getTileColor(val);
                grid.appendChild(tile);
            });
        }

        function getTileColor(val) {
            const colors = {2: '#eee4da', 4: '#ede0c8', 8: '#f2b179', 16: '#f59563', 32: '#f67c5f', 64: '#f65e3b', 128: '#edcf72', 256: '#edcc61', 512: '#edc850', 1024: '#edc53f', 2048: '#edc22e'};
            return colors[val] || '#3c3a32';
        }

        function handleTouchStart(e) {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        }

        function handleTouchEnd(e) {
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            const dx = touchEndX - touchStartX;
            const dy = touchEndY - touchStartY;
            if (Math.abs(dx) > Math.abs(dy)) {
                if (dx > 0) move2048('right');
                else move2048('left');
            } else {
                if (dy > 0) move2048('down');
                else move2048('up');
            }
        }

        function move2048(dir) {
            let moved = false;
            // –õ–æ–≥–∏–∫–∞ —Å–¥–≤–∏–≥–∞ (—É–ø—Ä–æ—â–µ–Ω–Ω–∞—è, –±–µ–∑ –ø–æ–ª–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ merge)
            // –î–ª—è –ø–æ–ª–Ω–æ–π 2048 –Ω—É–∂–Ω–∞ –±–æ–ª–µ–µ —Å–ª–æ–∂–Ω–∞—è –ª–æ–≥–∏–∫–∞, –Ω–æ –∑–¥–µ—Å—å –±–∞–∑–æ–≤–∞—è
            // –ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: –≠—Ç–æ —É–ø—Ä–æ—â–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è; –¥–ª—è –ø–æ–ª–Ω–æ–π –¥–æ–±–∞–≤–∏—Ç—å merge –∏ –ø—Ä–æ–≤–µ—Ä–∫–∏
            if (dir === 'up') {
                for (let j = 0; j < 4; j++) {
                    for (let i = 1; i < 4; i++) {
                        if (board2048[i][j] !== 0 && board2048[i-1][j] === 0) {
                            board2048[i-1][j] = board2048[i][j];
                            board2048[i][j] = 0;
                            moved = true;
                        } else if (board2048[i][j] !== 0 && board2048[i-1][j] === board2048[i][j]) {
                            board2048[i-1][j] *= 2;
                            score2048 += board2048[i-1][j];
                            board2048[i][j] = 0;
                            moved = true;
                        }
                    }
                }
            }
            // –ê–Ω–∞–ª–æ–≥–∏—á–Ω–æ –¥–ª—è –¥—Ä—É–≥–∏—Ö –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–π (left, right, down) - –¥–æ–±–∞–≤–∏—Ç—å –ø–æ—Ö–æ–∂—É—é –ª–æ–≥–∏–∫—É
            // –î–ª—è brevity, —Ä–µ–∞–ª–∏–∑—É—é —Ç–æ–ª—å–∫–æ up; —Ä–∞—Å—à–∏—Ä–∏—Ç—å –ø–æ –∞–Ω–∞–ª–æ–≥–∏–∏
            if (moved) {
                addRandomTile();
                draw2048Board();
                update2048Score();
                if (board2048.flat().includes(2048)) alert('–í—ã –≤—ã–∏–≥—Ä–∞–ª–∏!');
            }
        }

        function update2048Score() {
            document.getElementById('game-2048-score').textContent = `–°—á–µ—Ç: ${score2048}`;
        }

        function reset2048() {
            init2048();
        }

        // –ö–∞–º–µ–Ω—å-–ù–æ–∂–Ω–∏—Ü—ã-–ë—É–º–∞–≥–∞ (2 –∏–≥—Ä–æ–∫–∞, –ø–æ –æ—á–µ—Ä–µ–¥–∏)
        let rpsPlayer1Choice, rpsPlayer2Choice, rpsCurrentPlayer = 1;

        function initRPS() {
            rpsPlayer1Choice = null;
            rpsPlayer2Choice = null;
            rpsCurrentPlayer = 1;
            updateRPSStatus('–ò–≥—Ä–æ–∫ 1: –í—ã–±–µ—Ä–∏—Ç–µ');
            document.getElementById('rps-result').textContent = '';
            document.getElementById('rps-options').style.display = 'flex';
        }

        function playRPS(choice) {
            if (rpsCurrentPlayer === 1) {
                rpsPlayer1Choice = choice;
                updateRPSStatus('–ò–≥—Ä–æ–∫ 2: –í—ã–±–µ—Ä–∏—Ç–µ');
                rpsCurrentPlayer = 2;
            } else {
                rpsPlayer2Choice = choice;
                determineRPSWinner();
                document.getElementById('rps-options').style.display = 'none';
            }
        }

        function determineRPSWinner() {
            if (rpsPlayer1Choice === rpsPlayer2Choice) {
                document.getElementById('rps-result').textContent = '–ù–∏—á—å—è!';
            } else if (
                (rpsPlayer1Choice === 'rock' && rpsPlayer2Choice === 'scissors') ||
                (rpsPlayer1Choice === 'scissors' && rpsPlayer2Choice === 'paper') ||
                (rpsPlayer1Choice === 'paper' && rpsPlayer2Choice === 'rock')
            ) {
                document.getElementById('rps-result').textContent = '–ü–æ–±–µ–¥–∏–ª –ò–≥—Ä–æ–∫ 1!';
            } else {
                document.getElementById('rps-result').textContent = '–ü–æ–±–µ–¥–∏–ª –ò–≥—Ä–æ–∫ 2!';
            }
        }

        function updateRPSStatus(msg) {
            document.querySelector('#rps p').textContent = msg;
        }

        function resetRPS() {
            initRPS();
        }

        // –ú–æ—Ä—Å–∫–æ–π –ë–æ–π (2 –∏–≥—Ä–æ–∫–∞, —É–ø—Ä–æ—â–µ–Ω–Ω—ã–π 5x5, –ø–æ –æ—á–µ—Ä–µ–¥–∏ –Ω–∞ –æ–¥–Ω–æ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ)
        let bsPlayer1Ships = [], bsPlayer2Ships = [], bsCurrentPlayer = 1, bsPhase = 'setup1';

        function initBattleship() {
            bsPlayer1Ships = [];
            bsPlayer2Ships = [];
            bsCurrentPlayer = 1;
            bsPhase = 'setup1';
            const grid1 = document.getElementById('player1-grid');
            const grid2 = document.getElementById('player2-grid');
            grid1.innerHTML = '';
            grid2.innerHTML = '';
            grid2.classList.add('hidden');
            for (let i = 0; i < 25; i++) {
                const cell1 = document.createElement('div');
                cell1.classList.add('bs-cell');
                cell1.dataset.index = i;
                cell1.addEventListener('touchend', handleBattleshipClick);
                grid1.appendChild(cell1);
                const cell2 = cell1.cloneNode();
                grid2.appendChild(cell2);
            }
            updateBattleshipStatus('–†–∞—Å—Å—Ç–∞–Ω–æ–≤–∫–∞ –∫–æ—Ä–∞–±–ª–µ–π –¥–ª—è –ò–≥—Ä–æ–∫–∞ 1 (–≤—ã–±–µ—Ä–∏—Ç–µ 3 –∫–ª–µ—Ç–∫–∏)');
        }

        function handleBattleshipClick(e) {
            e.preventDefault();
            const index = parseInt(e.target.dataset.index);
            if (bsPhase === 'setup1') {
                if (bsPlayer1Ships.includes(index)) return;
                bsPlayer1Ships.push(index);
                e.target.style.backgroundColor = 'green';
                if (bsPlayer1Ships.length === 3) {
                    bsPhase = 'setup2';
                    document.getElementById('player1-grid').classList.add('hidden');
                    document.getElementById('player2-grid').classList.remove('hidden');
                    updateBattleshipStatus('–†–∞—Å—Å—Ç–∞–Ω–æ–≤–∫–∞ –∫–æ—Ä–∞–±–ª–µ–π –¥–ª—è –ò–≥—Ä–æ–∫–∞ 2 (–≤—ã–±–µ—Ä–∏—Ç–µ 3 –∫–ª–µ—Ç–∫–∏)');
                }
            } else if (bsPhase === 'setup2') {
                if (bsPlayer2Ships.includes(index)) return;
                bsPlayer2Ships.push(index);
                e.target.style.backgroundColor = 'green';
                if (bsPlayer2Ships.length === 3) {
                    bsPhase = 'play';
                    document.getElementById('startBattleshipPlay').style.display = 'none';
                    updateBattleshipStatus('–•–æ–¥ –ò–≥—Ä–æ–∫–∞ 1 (–∞—Ç–∞–∫—É–π—Ç–µ –ø–æ–ª–µ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞)');
                    document.getElementById('player1-grid').classList.remove('hidden');
                    document.getElementById('player2-grid').classList.remove('hidden');
                }
            } else if (bsPhase === 'play') {
                const targetGrid = bsCurrentPlayer === 1 ? document.getElementById('player2-grid') : document.getElementById('player1-grid');
                const targetShips = bsCurrentPlayer === 1 ? bsPlayer2Ships : bsPlayer1Ships;
                const cell = targetGrid.children[index];
                if (cell.classList.contains('bs-hit') || cell.classList.contains('bs-miss')) return;
                if (targetShips.includes(index)) {
                    cell.classList.add('bs-hit');
                    targetShips.splice(targetShips.indexOf(index), 1);
                    if (targetShips.length === 0) {
                        alert(`–ü–æ–±–µ–¥–∏–ª –ò–≥—Ä–æ–∫ ${bsCurrentPlayer}!`);
                        bsPhase = 'over';
                    }
                } else {
                    cell.classList.add('bs-miss');
                }
                bsCurrentPlayer = bsCurrentPlayer === 1 ? 2 : 1;
                updateBattleshipStatus(`–•–æ–¥ –ò–≥—Ä–æ–∫–∞ ${bsCurrentPlayer} (–∞—Ç–∞–∫—É–π—Ç–µ –ø–æ–ª–µ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞)`);
            }
        }

        function startBattleshipPlay() {} // –ù–µ –Ω—É–∂–Ω–æ, —Ç–∞–∫ –∫–∞–∫ –ø–æ—Å–ª–µ setup –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏

        function updateBattleshipStatus(msg) {
            document.getElementById('battleship-status').textContent = msg;
        }

        function resetBattleship() {
            initBattleship();
        }

        // –°–ª–∞–π–¥–µ—Ä-–ü–∞–∑–ª (1 –∏–≥—Ä–æ–∫, –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–∞—è: 8-puzzle)
        let puzzleTiles = [1,2,3,4,5,6,7,8,0];
        let emptyIndex = 8;

        function initPuzzle() {
            puzzleTiles = [1,2,3,4,5,6,7,8,0].sort(() => Math.random() - 0.5);
            emptyIndex = puzzleTiles.indexOf(0);
            drawPuzzle();
            updatePuzzleStatus('–°–æ–±–µ—Ä–∏—Ç–µ —á–∏—Å–ª–∞ –ø–æ –ø–æ—Ä—è–¥–∫—É!');
        }

        function drawPuzzle() {
            const grid = document.getElementById('puzzle-grid');
            grid.innerHTML = '';
            puzzleTiles.forEach((val, i) => {
                const tile = document.createElement('div');
                tile.classList.add('puzzle-tile');
                if (val === 0) tile.classList.add('empty');
                tile.textContent = val || '';
                tile.dataset.index = i;
                tile.addEventListener('touchend', handlePuzzleClick);
                grid.appendChild(tile);
            });
        }

        function handlePuzzleClick(e) {
            e.preventDefault();
            const index = parseInt(e.target.dataset.index);
            const moves = [1, -1, 3, -3]; // –í–æ–∑–º–æ–∂–Ω—ã–µ —Å–¥–≤–∏–≥–∏
            for (let move of moves) {
                if (index + move === emptyIndex && Math.abs(move) === 1 ? Math.floor(index / 3) === Math.floor(emptyIndex / 3) : true) {
                    [puzzleTiles[index], puzzleTiles[emptyIndex]] = [puzzleTiles[emptyIndex], puzzleTiles[index]];
                    emptyIndex = index;
                    drawPuzzle();
                    if (puzzleTiles.join(',') === '1,2,3,4,5,6,7,8,0') {
                        updatePuzzleStatus('–ü–∞–∑–ª —Å–æ–±—Ä–∞–Ω!');
                    }
                    return;
                }
            }
        }

        function updatePuzzleStatus(msg) {
            document.getElementById('puzzle-status').textContent = msg;
        }

        function resetPuzzle() {
            initPuzzle();
        }
    </script>
</body>
</html>
